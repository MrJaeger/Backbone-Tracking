// Generated by CoffeeScript 1.3.3
(function() {

  describe("A Test Suite for Backbone Tracking", function() {
    var model;
    model = new Backbone.Model;
    beforeEach(function() {
      return model = new Backbone.Model;
    });
    afterEach(function() {
      return model.stopTracking();
    });
    return describe("APIS", function() {
      describe("Start Tracking", function() {
        return it("Should append the correct attributes to the model", function() {
          model.startTracking();
          expect(model.version).toBeDefined();
          return expect(model.attributeArray).toBeDefined();
        });
      });
      describe("Stop Tracking", function() {
        return it("Should remove the correct attributes as well as unbind any events related to tracking", function() {
          model.startTracking({
            onChange: true,
            onSave: true
          });
          expect(model.version).toBeDefined();
          expect(model.attributeArray).toBeDefined();
          expect(_.size(model._callbacks)).toEqual(2);
          model.stopTracking();
          expect(model.version).toBeUndefined();
          expect(model.attributeArray).toBeUndefined();
          return expect(_.size(model._callbacks)).toEqual(0);
        });
      });
      describe("Commit", function() {
        afterEach(function() {
          return model.stopTracking();
        });
        describe("No Options Set", function() {
          return it("Should create a new version when the model is commited", function() {
            model.startTracking();
            model.set('name', 'Andrew');
            model.commit();
            return expect(model.version).toEqual(1);
          });
        });
        return describe("OnChange Option Set", function() {
          return it("Should create a new version when the model is set", function() {
            model.startTracking({
              onChange: true
            });
            model.set('name', 'Andrew');
            return expect(model.version).toEqual(1);
          });
        });
        /* TO DO Tests for OnSave Option Set
        */

      });
      describe("Revert", function() {
        beforeEach(function() {
          model.set('name', 'Andrew');
          return model.startTracking({
            onChange: true
          });
        });
        it("Should revert by one version when no argument is passed", function() {
          model.set('name', 'Bob');
          model.revert();
          return expect(model.get('name')).toEqual('Andrew');
        });
        it("Should stay at the current version if no previous version exists", function() {
          model.revert();
          return expect(model.get('name')).toEqual('Andrew');
        });
        it("Should revert by the given number of versions if the argument versionsBehind is passed", function() {
          model.set('name', 'Bob');
          model.set('name', 'Gerard');
          model.revert(2);
          return expect(model.get('name')).toEqual('Andrew');
        });
        return it("Should stay on the current version if the number of versions passed is too large", function() {
          model.set('name', 'Bob');
          model.revert(20);
          return expect(model.get('name')).toEqual('Bob');
        });
      });
      describe("Revert To Original", function() {
        beforeEach(function() {
          model.set('name', 'Andrew');
          return model.startTracking({
            onChange: true
          });
        });
        return it("Should revert to the original state of the model", function() {
          model.set('name', 'Bob');
          model.set('name', 'Gerard');
          model.revertToOriginal();
          return expect(model.get('name')).toEqual('Andrew');
        });
      });
      describe("Progress", function() {
        beforeEach(function() {
          model.set('name', 'Andrew');
          return model.startTracking({
            onChange: true
          });
        });
        it("Should progress by one version when no argument is passed", function() {
          model.set('name', 'Bob');
          model.revert();
          model.progress();
          return expect(model.get('name')).toEqual('Bob');
        });
        it("Should stay at the current version if no more recent version exists", function() {
          model.progress();
          return expect(model.get('name')).toEqual('Andrew');
        });
        it("Should progress by the given number of versions if the argument versionsAhead is passed", function() {
          model.set('name', 'Bob');
          model.set('name', 'Gerard');
          model.revertToOriginal();
          model.progress(2);
          return expect(model.get('name')).toEqual('Gerard');
        });
        return it("Should stay on the current version if the number of versions passed is too large", function() {
          model.set('name', 'Bob');
          model.progress(20);
          return expect(model.get('name')).toEqual('Bob');
        });
      });
      describe("Progress To Newest", function() {
        beforeEach(function() {
          model.set('name', 'Andrew');
          return model.startTracking({
            onChange: true
          });
        });
        return it("Should progress to the newest version of the model", function() {
          model.set('name', 'Bob');
          model.set('name', 'Gerard');
          model.revertToOriginal();
          model.progressToNewest();
          return expect(model.get('name')).toEqual('Gerard');
        });
      });
      describe("Clear", function() {
        return it("Should clear changes that were made but never commited", function() {
          model.set('name', 'Andrew');
          model.startTracking();
          model.set('name', 'Bob');
          model.clear();
          return expect(model.get('name')).toEqual('Andrew');
        });
      });
      return describe("Where", function() {
        beforeEach(function() {
          model.set('name', 'Andrew');
          return model.startTracking({
            onChange: true
          });
        });
        return it("Should find the the correct version of the model based on the query", function() {
          model.set('name', 'Bob');
          model.set('name', 'Gerard');
          model.where({
            name: 'Bob'
          });
          return expect(model.get('name')).toEqual('Bob');
        });
      });
    });
  });

}).call(this);
